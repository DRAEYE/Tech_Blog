## 消息加密 - 密码学入门

### 前言

当无人系统在进行消息传递时，面临着各式各样的安全攻击。主要的攻击形式有**截取**、**中断**、**篡改**、**伪造**、**重放**、**否认**这几种形式。

<img src="/home/qi/Pictures/IMG_7667.jpg" alt="MAVLink v2 packet" style="zoom:10%;" />



MAVLink协议是目前无人系统中使用较多的通信协议，具备开源、便捷、轻量化等特点，为开发者提供了便利。但是，MAVLink 1的安全性较差，对于使用MAVLink 1作为通信协议的无人系统，消息能够轻易的被攻击方截取（获得无人机的重要信息）、篡改（更改地面站发送的指控信息）、伪造（伪装成已方发送错误指令）、重放（高强度的重放攻击使得通信系统瘫痪）。

MAVLInk 2协议中加入了签名机制，可以通过签名帧校验的方式让收发双方确认身份，起到了一定的安全作用。但是，官方文档中只简单介绍了签名机制，并未提供完整的使用方法，且提供的例程和PX4代码中均为启用该签名机制（即使使用MAVLink 2协议，也是阉割版的）。其次，MAVLink 2的明文部分并未进行加密，因此当消息被获取时，仍然存在关键信息泄露的风险。

本文主要讲解MAVLink 2协议的入门、加密所需要的密码学基础、加密及签名机制的使用教程，最终给出全套可用的源码。



### 密码学入门

密码学（cryptology）作为数学的一个分支，是密码编码学和密码分析学的统称。

加密算法分 **对称加密** 和 **非对称加密**，其中对称加密算法的加密与解密 **密钥相同**，非对称加密算法的加密密钥与解密 **密钥不同**，此外，还有一类 **不需要密钥** 的 **散列算法**。

> 常见的 对称加密 算法主要有 DES、3DES、AES 等，常见的 非对称算法 主要有 RSA、DSA 等，散列算法 主要有 SHA-1、MD5 等。

### 对称加密算法

**对称加密算法**是应用较早的加密算法，技术成熟。在对称加密算法中，数据发信方将明文（原始数据）和加密密钥一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。**在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥。**

> 对称加密算法的特点是算法公开、计算量小、加密速度快、加密效率高。
>
> 不足之处是，交易双方都使用同样钥匙，安全性得不到保证。此外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的惟一钥匙，这会使得发收信双方所拥有的钥匙数量呈几何级数增长，[密钥管理](https://baike.baidu.com/item/密钥管理)成为用户的负担。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。而与[公开密钥](https://baike.baidu.com/item/公开密钥)加密算法比起来，对称加密算法能够提供加密和认证却缺乏了签名功能，使得使用范围有所缩小。在计算机专网系统中广泛使用的对称加密算法有DES和IDEA等。[美国国家标准局](https://baike.baidu.com/item/美国国家标准局)倡导的AES即将作为新标准取代DES。
>
> 对称加密算法的优点在于加解密的高速度和使用长[密钥](https://baike.baidu.com/item/密钥)时的难破解性。假设两个用户需要使用对称加密方法加密然后交换数据，则用户最少需要2个密钥并交换使用，如果企业内用户有n个，则整个企业共需要n×(n-1) 个密钥，密钥的生成和分发将成为企业信息部门的恶梦。对称加密算法的安全性取决于加密密钥的保存情况，但要求企业中每一个持有密钥的人都保守秘密是不可能的，他们通常会有意无意的把密钥泄漏出去——如果一个用户使用的密钥被入侵者所获得，入侵者便可以读取该用户[密钥加密](https://baike.baidu.com/item/密钥加密)的所有文档，如果整个企业共用一个加密密钥，那整个企业文档的保密性便无从谈起。

**常见对称加密算法**

`AES`、`DES`、`3DES` 都是 **对称** 的 **块加密算法**，**加解密** 的过程是 **可逆的**。

- **DES**

  数据加密标准（Data Encryption Standard，缩写为DES）曾经是世界标准。DES的整个体制是公开的，系统的安全性完全靠密钥保密。

  DES 加密算法是一种 分组密码，以 64 位为 分组对数据 加密，它的 密钥长度 是 56 位，加密解密 用 同一算法。

  DES 加密算法是对 密钥 进行保密，而 公开算法，包括加密和解密算法。这样，只有掌握了和发送方 相同密钥 的人才能解读由 DES加密算法加密的密文数据。因此，破译 DES 加密算法实际上就是 搜索密钥的编码。对于 56 位长度的 密钥 来说，如果用 穷举法 来进行搜索的话，其运算次数为 2 ^ 56 次。

- **3DES**
  是基于 DES 的 对称算法，对 一块数据 用 三个不同的密钥 进行 三次加密，强度更高。

- **AES** 

  高级加密标准（Advanced Encryption Standard，缩写为AES）是DES的替代者，于2001年正式发布。

  AES 加密算法是密码学中的 高级加密标准，该加密算法采用 对称分组密码体制，密钥长度的最少支持为 128 位、 192 位、256 位，分组长度 128 位，算法应易于各种硬件和软件实现。这种加密算法是美国联邦政府采用的 区块加密标准。

  AES 本身就是为了取代 DES 的，AES 具有更好的 安全性、效率 和 灵活性。	

| 名称 | 密钥名称        | 运行速度 | 安全性 | 资源消耗 |
| ---- | --------------- | -------- | ------ | -------- |
| DES  | 56位            | 较快     | 低     | 中       |
| 3DES | 112位或168位    | 慢       | 中     | 高       |
| AES  | 128、192、256位 | 快       | 高     | 低       |

#### 破解AES需要多少时间？

以AES-128算法为例，平均需要尝试2^127 ≈ 1.7*10^38个128bit的随机数作为密钥进行加解密运算，方能找到正确的密钥。

常言道，“天下武功，唯快不破”；反之，天下密码，快必可破。问题是，那得有多快？我们知道，比特币网络在全球范围内调用了非常庞大的硬件资源以达到极高的运算效率，每秒钟操作的Hash运算（SHA-256）可高达2.5644*10^19次。虽然AES和SHA-256算法并不相同，运算量也有所差异，但我们不妨近似地用该数据估算全球人民众志成城破解AES算法所需要的时间。

假设AES的运算效率为2.5644*10^19 ≈ 2^64.4753次/秒，则进行2^127次AES运算所需要的时间为：
2^127 / 2^64.4753 ≈ 2^62.5247秒 ≈ 6.6345* 10^18 秒 ≈ 1.8429 *10^15 小时 ≈ 7.6789* 10^13 天 ≈ 2.104 * 10^11年 ≈ 210,400,000,000 年

###  非对称加密算法

**非对称加密算法是一种密钥的保密方法**。非对称加密算法需要两个密钥：**公开密钥**（public key:简称公钥）和**私有密钥**（private key:简称私钥）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将公钥公开，需要向甲方发送信息的其他角色(乙方)使用该密钥(甲方的公钥)对机密信息进行加密后再发送给甲方；甲方再用自己私钥对加密后的信息进行解密。甲方想要回复乙方时正好相反，使用乙方的公钥对数据进行加密，同理，乙方使用自己的私钥来进行解密。

非对称密码体制的特点：**算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快**。对称密码体制中只有一种密钥，并且是非公开的，如果要解密就得让对方知道密钥。所以保证其安全性就是保证密钥的安全，而非对称密钥体制有两种密钥，其中一个是公开的，这样就可以不需要像对称密码那样传输对方的密钥了。这样安全性就大了很多。

**工作流程**

1. A要向B发送信息，A和B都要产生一对用于加密非对称加密算法和解密的公钥和私钥。

2. A的私钥保密，A的公钥告诉B；B的私钥保密，B的公钥告诉A。

3. A要给B发送信息时，A用B的公钥加密信息，因为A知道B的公钥。

4. A将这个消息发给B（已经用B的公钥加密消息）。

5. B收到这个消息后，B用自己的私钥解密A的消息。其他所有收到这个报文的人都无法解密，因为只有B才有B的私钥。

**常见的非对称加密算法**

- **RSA算法**

  RSA 加密算法是目前最有影响力的 公钥加密算法，并且被普遍认为是目前 最优秀的公钥方案 之一。RSA 是第一个能同时用于 加密 和 数字签名 的算法，它能够 抵抗 到目前为止已知的 所有密码攻击，已被 ISO 推荐为公钥数据加密标准。

  > RSA 加密算法 基于一个十分简单的数论事实：将两个大 素数 相乘十分容易，但想要对其乘积进行 因式分解 却极其困难，因此可以将 乘积 公开作为 加密密钥。

- **ECC算法**

| 名称 | 成熟度 | 安全性 | 运算速度 | 资源消耗 |
| ---- | ------ | ------ | -------- | -------- |
| RSA  | 高     | 高     | 中       | 中       |
| ECC  | 高     | 高     | 慢       | 高       |



### Hash算法

**什么是Hash（散列算法，杂凑算法）**

Hash，音译“哈希”，一般翻译做“散列”，就是把任意长度的数据作为输入，然后通过Hash散列算法得到一个固定长度的输出值，该输出值就是散列值，它是一种数据压缩映射关系。 简单来说就是将做任意长度的消息压缩到某一固定长度的消息摘要的函数。

**数学定义**

Hash函数H将可变长度的数据块M作为输入，产生**固定长度的Hash值**h = H(M)。

散列函数是一个多对一的函数，因此在理论上，必定存在不同的输入对应相同的散列输出，但这种情况在实际中必须不可能出现（计算上不可行）

例如：

<img src="/home/qi/.config/Typora/typora-user-images/image-20200513092437107.png" width="300" alt="哈希算法示例" align=left>

**Hash散列算法特征**

**正向快速**：给定明文和hash算法，在有限时间和有限资源内计算Hash值。

**不可逆性**：给定任意的Hash值，在有限时间内很难逆推出明文。

**输入敏感**：如果输入的数据信息被轻微修改，输出的Hash值也会有很明显的变化。

**抗碰撞性**：如果满足x≠y且H(x)=H(y)，则称为**碰撞**。任意输入不同的数据，其输出的Hash值不可能相同，如果给定一个数据块去找出其具有相同的Hash值，那是几乎不可能。

Hash散列算法实现原理

算法实现可以有：加运算，位运算，乘运算，等。。。

它的最大特征就是：将做任意长度的消息压缩到某一固定长度的值。

**密码学Hash函数的安全性需求**

![img](https://images2015.cnblogs.com/blog/929265/201606/929265-20160628153109156-223536527.jpg)

 	**弱Hash函数：**只满足以上前五个要求的Hash函数。

 	**强Hash函数：**满足以上前六个要求的Hash函数。

​	 强Hash函数能够保证免受以下攻击：假设Bob写一条借据消息并发送给Alice，Alice在借据上签名认可。Bob如果能找到两条消息具有同样的Hash值，其中一个借据消息要求Alice归还金额较小，另一个金额很大，那么让Alice签下第一个小额借据后，Bob就能声称第二个借据是真实的（将Alice在第一个借据的签名附到第二个借据中）。

下图展示了抗原像攻击、抗弱碰撞攻击和抗强碰撞攻击三者之间的关系

<img src="https://images2015.cnblogs.com/blog/929265/201606/929265-20160628154137421-1909321177.png" width="300" alt="Hash函数安全特性之间的联系" align=center>

在传统观念中并没有把伪随机性作为密码学Hash函数的安全性需求，但在实际应用中或多或少有所要求。密码学Hash函数通常用于密钥产生、伪随机数发生器以及消息完整性应用，上述三个应用都要求Hash函数的输出是随机的。

**对Hash函数的攻击**

**无限输入集合向有限集合的压缩映射是必然会出现碰撞的**，解决碰撞的一个有效方法是增加映射空间长度。那么我们不禁要思考：那我该选择多少bit的哈希函数才能避免碰撞呢？

其实面对这个问题的时候，大部分人是这么想的：使用32bit的哈希函数大约有42亿种组合可能，那么产生哈希碰撞岂不是42亿分之一，貌似可以高枕无忧了，先看一个有趣的问题：

<img src="https://pic4.zhimg.com/80/v2-a32f98d3c9acfff2c17a02a7986d45af_hd.jpg" width="300" alt="Hash函数安全特性之间的联系" align=center>

> 生日悖论是指在不少于 23 个人中至少有两人生日相同的概率大于 50%。例如在一个 30 人的小学班级中，存在两人生日相同的概率为 70%。对于 60 人的大班，这种概率要大于 99%。从引起逻辑矛盾的角度来说，生日悖论并不是一种 “悖论”。但这个数学事实十分反直觉，故称之为一个悖论。
>
> 计算方式为 有相同生日的概率 = 1 - 无相同生日的概率

<img src="/home/qi/.config/Typora/typora-user-images/image-20200513103359962.png" width="500" alt="Hash函数安全特性之间的联系" align=center>

**所以对于48bit的散列长度，在2^24  = 1677万个随机的散列值就有50%的概率发现一个碰撞。**

<img src="/home/qi/.config/Typora/typora-user-images/image-20200513103839986.png" width="500" alt="Hash函数安全特性之间的联系" align=center>



1. **穷举攻击**

   - **原像攻击和第二原像攻击**（即破译明文）

     ​        攻击者对给定的Hash值h，试图找到满足H(y) = h的y。穷举攻击的方法是随机选择y，尝试计算其Hash值直到碰撞出现。对于m位的Hash值，穷举的规模大约是2^m，对于攻击者平均尝试次数为2^(m-1)，才能找到一个满足H(y)=h的y值。

   - **碰撞攻击(生日攻击)**（即篡改数据）

     　　对于碰撞攻击，攻击者试图找到两个消息或数据块x和y，满足H(x)=H(y)，与原像攻击和第二原像攻击相比，其穷举的规模相对更小一些，这也通过数学上的生日悖论得到印证。本质上，如果我们在均匀分布的0到N-1的范围内选择随机整数变量，那么在N^(1/2)次选择后发生重复的概率就会超过0.5。因此，对于m位的Hash值，如果我们随机选择数据块，预计在2^(m/2)次尝试后就能找到两个具有相同Hash值的数据块。

     - 发送方A准备对文本消息x进行签名（尚未签名，但可预期要签名的文件内容），其使用的方法是：用A的私钥对m位的Hash码加密并将加密后的Hash码附于消息之后。
     - 攻击者产生该消息x的2^(m/2)种变式x'，每种变式都表达相同的意义，将这些消息以及对应的Hash值存储起来。
     - 攻击者准备伪造一条消息y，并想获取A的签名，只需要伪造y的变式y',然后计算H(y')，并与所有的H(x')进行比对，直到碰撞出现。
     - 攻击者将发生碰撞的消息x'提供给A签名，然后将该签名附于伪造消息y'后。这样攻击者就在不知道A密钥的情况下获得了有A数字签名的消息y'，并可以此获利。

​	

2. **密码分析**

   ​       对Hash函数的密码分析攻击，也是利用算法的某种性质而不是通过穷举来进行攻击的。理想的Hash函数算法要求密码分析攻击所需的代价大于或等于穷举攻击所需的代价。

> 军用加密强度不如比特币，再高的装备现在也无法撼动比特币算法，比特币时间越长越见其算法不可动摇。就算算法崩塌，也是军事和银行先崩溃，比特币那时更值钱了。

**SHA256**

SHA (Secure Hash Algorithm，译作安全散列算法) 是美国国家安全局 (NSA) 设计，美国国家标准与技术研究院 (NIST) 发布的一系列密码散列函数，经历了SHA-0，SHA-1，SHA-2，SHA-3系列发展。SHA-2在2001年由美国国家标准与技术研究院（NIST）在2001年发布，NSA于2007年正式宣布在全球范围内征集新新一代（SHA-3）算法设计，2012年公布评选结果， Keccak算法最终获胜成为唯一官方标准SHA-3算法，但还有四种算法同时进入了第三轮评选，分别是：BLAKE, GrøSTL, JH和SKEIN，这些算法其实也非常安全，而且经受审查，被各种竞争币频繁使用。

比特币采用SHA256算法，该算法属于SHA-2系列，在中本聪发明比特币时（2008）被公认为最安全最先进的算法之一。除了生成地址中有一个环节使用了REPID-160算法，比特币系统中但凡有需要做Hash运算的地方都是用SHA256。随着比特币被更多人了解，大家开始好奇中本聪为何选择了SHA256，同时对SHA256的安全性发表各种意见，SHA256妥妥经受了质疑，到目前为止，没有公开的证据表明SHA256有漏洞，SHA256依然牢牢抗住保卫比特币安全的大旗。当然大家心里都明白，没有永远安全的算法，SHA256被替代是早晚的事，中本聪自己也说明了算法升级的必要和过程。

**算法过程**

把信息摘要分成了A，B，C，D，E，F，G，H八段。在循环过程中交替运算A，B，C，D，最终组成256bit的摘要结果。

![img](https://img-blog.csdn.net/20180401214228406)

SHA-256伪代码

- https://baike.baidu.com/item/SHA-2



**历史**

SHA-0和SHA-1可将一个最大2的64次方位元的讯息，转换成一串160位元的讯息摘要；其设计原理相似于MIT教授Ronald L. Rivest所设计的密码学杂凑算法[MD4](https://baike.baidu.com/item/MD4)和[MD5](https://baike.baidu.com/item/MD5)。

SHA-256和SHA-512是很新的杂凑函数，前者以定义一个word为32位元，后者则定义一个word为64位元。它们分别使用了不同的偏移量，或用不同的常数，然而，实际上二者结构是相同的，只在循环执行的次数上有所差异。SHA-224以及SHA-384则是前述二种杂凑函数的截短版，利用不同的初始值做计算。



SHA-2的不同版本

SHA-2是一系列SHA算法变体的总称，其中包含如下子版本：

SHA-256：可以生成长度256bit的信息摘要。

SHA-224：SHA-256的“阉割版”，可以生成长度224bit的信息摘要。

SHA-512：可以生成长度512bit的信息摘要。

SHA-384：SHA-512的“阉割版”，可以生成长度384bit的信息摘要。

SHA-224和SHA-256基本上是相同的，除了：

- h0到h7的初始值不同，以及
- SHA-224输出时截掉h7的函数值。

SHA-512和SHA-256的结构相同，但：

- SHA-512所有的数字都是64位，
- SHA-512运行80次加密循环而非64次，
- SHA-512初始值和常量拉长成64位，以及
- 二者比特的偏移量和循环位移量不同。

SHA-384和SHA-512基本上是相同的，除了：

- h0到h7的初始值不同，以及
- SHA-384输出时截掉h6和h7的函数值。

显然，信息摘要越长，发生碰撞的几率就越低，破解的难度就越大。但同时，耗费的性能和占用的空间也就越高。

小明：为什么SHA-2要有这么多的版本呢？只使用最长的一种不就行了吗？

老师：这是为了适应不同的应用场景，从而对安全、性能、空间等因素做出权衡。比如说过我的需求仅仅是验证数据完整性，使用SHA-512显然是浪费了。另外，如果想要追求安全性，也可以考虑把多种摘要算法结合使用。比如下面这样：

明文： abcd

MD5摘要：e2fc714c4727ee9395f324cd2e7f331f

SHA-256摘要：

88d4266fd4e6338d13b845fcf289579d209c897823b9217da3e161936f031589

合成摘要：e2fc714c4727ee93209c897823b9217da3e161936f031589

取MD摘要的前16和SHA-256摘要的后32位，拼成一个长度48位的合成摘要。这样除非知道拼接规则，否则外人是无从破解的。


对于SHA-256

- 无论输入多长，都输出`64`个字符，共`32`字节（byte），`256`位（bit）
- 输出只包含数字`0`~`9`和字母`A`~`F`，大小写不敏感

但MAVLink中是中只截取了SHA-256算法的前48bit




